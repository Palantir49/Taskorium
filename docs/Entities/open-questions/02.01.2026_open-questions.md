## ❓ Открытые вопросы

### Вопрос 1: Можно ли завершать задачу без входа «в работу»?
- **Контекст**: Нет конкретной реализации
- **Зачем решать**: Если запрещать, то это ограничение пользователя, если разрешить - возможно несоответствие дат
- **Варианты**:
    - **Разрешить** - изменение статуса никак не привязано к типу. Важно для дальнейшей реализации аналитики
	    - **без изменения дат** —  при перемещении `Initial → Terminal` оставляет `StartDate = null`
	    - **с присвоением дат** —  при перемещении `Initial → Terminal` присваивает `StartDate = now` 
	- **Запретить** — Ограничивает пользователя, принуждая следовать `Initial → InProgress → Terminal`, но даты сохраняют свою актуальность
- **Влияние**: 
    - Если разрешить с изменением дат - при изменении статуса на `Terminal` **и** `StartDate = null` → `StartDate = now`
    - Если запретить - добавить валидацию в методе изменения статуса на проверку последовательности `Initial → InProgress → Terminal`
- **Решение**: 
	- ADR-01: **запретить** - добавить валидацию в методе изменения статуса на проверку последовательности `Initial → InProgress → Terminal`
	- Реализуем StatusTransitions

### Вопрос 2: Как даты начала и завершения задачи должны реагировать на откат типа?
- **Контекст**: Сейчас при переходе из `Initial → InProgress` изменяется `StartDate = now`, а при `InProgress → Terminal` `DueDate = now`
- **Зачем решать**: Выработать поведение дат при возможном "откате" статуса
- **Варианты**:
    - **Присваивать null при "откате"** — сохраняет естественный порядок перехода между типами статусов 
    - **Присваивать null при "откате" при явном обозначении** — пользователь сам определяет изменение дат при "откате"
    - **Не изменять даты** — сохранение первичных присвоенных значений  
- **Влияние**:  
    - **Присваивать null при "откате"** - при "откате" типа статуса из `Terminal` → `DueDate = null`. При откате в `Initial` → `StartDate = null`
    - **Присваивать null при "откате" при явном обозначении** — если указано обнуление, то действовать как при **Присваивать null при "откате"**, иначе не изменять даты
    - **Не изменять даты** - если `DueDate` или `StartDate` присвоено значение - не изменять.
- **Решение**: StartDate - никогда не изменяется. в начальный статус нельзя переносить. DueDate - null

### Вопрос 3: Как присваивается статус при создании новой задачи
- **Контекст**: Сейчас при создании задачи можно указать любой id (в планах изменить на указание id статуса, который принадлежит проекту)
- **Зачем решать**: Выработать поведение дат при возможном "откате" статуса
- **Варианты**:
    - **Добавить к статусам обозначение "первичный"** — при создании задачи искать первичный статус и присваивать его
    - **Присваивать переданный статус** — присваивать id переданного статуса с отработкой жизненного цикла. 
- **Влияние**:
    - **Добавить к статусам обозначение "первичный"** — при создании задачи получить статус, принадлежащий проекту, с пометкой "первичный" и присвоить его id
    - **Присваивать переданный статус** — проверить что статус принадлежит проекту и присвоить его id. Сразу выполнять действия при переходе статуса.
- Решение: У проекта будет только 1 начальный статус, ограничить создание нескольких начальных и создавать новую задачу в нем.

### Вопрос 4: Разрешить изменение `ProjectId` и `Type`, если статус не используется?
- **Контекст**: Сейчас `ProjectId` и `Type` полностью неизменяемы. Но если статус *никем не используется* (создан и забыт), может быть полезно его «переназначить», а не удалять и создавать заново.  
- **Варианты**:  
    - **Разрешить** - если `количество_задач = 0`. Требует проверки при обновлении.  
    - **Запретить** - проще, безопаснее, соответствует принципу «immutable by default».
- **Влияние**:
    - **разрешить** - нужны методы изменения ProjectId и Type с предусловием.
    - **Запретить** - UI всегда предлагает «удалить + создать»
- **Решение**: нет, запрещаем

### Вопрос 5: Как обеспечить наличие `Initial`, `InProgress` и `Terminal` при создании проекта?
- **Контекст**: Без наличия статусов каждого типа нарушается логика работы 'Issue'
- **Варианты**:  
    - **Дефолтные статусы** - Автоматически создавать 3 статуса при создании проекта: `"Открыта" (Initial)`, `"В работе" (InProgress)` и `«Завершена» (Terminal)`.  
    - **Создание статусов при создании проекта** Требовать передачи базового набора статусов при создании проекта.
        - **Обработка в UI** - При создании проекта автоматически заполнять 3 поля статусов. Добавить возможность сразу создать нужные статусы и настроить их.
- **Влияние**
    - **Дефолтные статусы** - добавить создание статусов при создании проекта
    - **Создание статусов при создании проекта** - требует создания статусов с заданными параметрами и проверкой на наличие всех типов.
- Решение: При создании проекта сразу создаем 3 колонки как в варианте с дефолтом. Дальше пускай меняют как хотят. 

### Вопрос 6: Должен ли `IssueType` быть обязательным?
- **Контекст**:  Сейчас TaskTypeId является обязательным параметром
- **Зачем решать**: не вижу необходимости обязывать выставлять тип задачи, когда его отсутствие не будет ни на что влиять.
- **Варианты**:
    - **Обязательный**
    - **Необязательный**
- **Решение**: Добавить значение по умолчанию и ставить его, если не указано другого

### Вопрос 7: Есть ли смысл в отдельной таблице `IssueAssignees` или достаточно `ResponsibleId` + `CreatorId`?
- **Контекст**: первоначально в схеме есть таблица подразумевающая множество не точных связей между юзерами и задачами. Это выглядит гибко, но избыточно.
- **Варианты**:
    - **В пользу таблицы с определенными ролями** 
    - **В пользу таблицы с настраиваемыми ролями**
    - **только конкретные ответственные** - реализовать в Issue ссылки на юзеров ключевых ролей.
- **Влияние**:  
    - **В пользу таблицы** - позволит анализировать по каждому задействованному юзеру. 
	    - **с определенными ролями** - упрощенная вариация, где роли будут только разделять ответственность без возможности настройки
	    - **с настраиваемыми ролями** - вариант требующий реализацию ролей. Добавляет возможность реализовать настройку ролей по уровню занятости, начиная от простых уровней (условно, от "не занят" до "полная занятость"), заканчивая конкретными значениями.
    - **только конкретные ответственные** - простая реализация, но сильно срезает аналитику
- **пояснения для настраиваемых ролей**:  Например, роль наблюдатель будет иметь менее занятый тип. Скорее всего эта роль будет назначена какому-нибудь проверяющему, который не будет включен в основной процесс, а включиться только в конце, для проверки результата. Логично, что его занятость относительно исполнителей в разы ниже и выдавать аналитику по одной и той же задаче на ровне будет менее информативно.
- **Решение**: создаем `IssueAssignees`